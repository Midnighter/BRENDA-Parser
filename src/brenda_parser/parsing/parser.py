# -*- coding: utf-8 -*-

# Copyright (c) 2011 Jacobs University Bremen gGmbH
# Copyright (c) 2018 Moritz E. Beber
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""Parse BRENDA tokens using the provided grammar."""

from __future__ import absolute_import

import logging

from ply.yacc import yacc

import brenda_parser.models as models
from brenda_parser.exceptions import ValidationError
from brenda_parser.parsing.lexer import BRENDALexer

__all__ = ("BRENDAParser",)

LOGGER = logging.getLogger(__name__)


class BRENDAParser(object):
    """
    Parse the BRENDA flat file into database models.

    Implement the following rules using the tokens generated by an
    appropriate lexer.
    ::
        enzyme : ID EC_NUMBER comment
                 | END

        entry : ENTRY protein TEXT comment citation special
                | ENTRY protein TEXT comment
                | ENTRY protein TEXT

        protein_entry : PROTEIN_ENTRY new_protein protein_entry
                        | protein_entry protein_entry
                        | protein_entry ACCESSION CONTENT
                        | proteins

        comment : LPARENS comment RPARENS
                  | LPARENS RPARENS
                  | comment comment
                  | CONTENT

        special : LCURLY special RCURLY
                  | LCURLY RCURLY
                  | special special
                  | CONTENT

        proteins : POUND proteins POUND
                   | POUND POUND
                   | proteins proteins
                   | PROTEIN

        citations : LANGLE citations RANGLE
                    | LANGLE RANGLE
                    | citations citations
                    | CITATION

    """

    precedence = (
        ("left", "ENZYME"),
        ("left", "ASSEMBLE"),
        ("left", "REDUCE"),
        ("left", "COMBINE")
    )

    def __init__(self, lexer=None, **kw_args):
        """
        Instantiate a BRENDA parser.

        Parameters
        ----------
        lexer : ply.lex (optional)
            Any ply.lex lexer instance that generates the tokens listed in the
            rules. The default uses a BRENDALexer instance.
        kw_args :
            Keyword arguments are passed to the ply.yacc.yacc call.
        """
        super(BRENDAParser, self).__init__()
        self._lexer = BRENDALexer() if lexer is None else lexer
        self.tokens = self._lexer.tokens
        self.parser = yacc(module=self, errorlog=LOGGER, **kw_args)
        self._session = None
        self.proteins = dict()
        self.citations = dict()
        self._current_entry = None

    def parse(self, section, session, **kw_args):
        """
        Parse an entire enzyme section according to the rules.

        The parser fills a database ``Enzyme`` model with information and
        returns it.

        Parameters
        ----------
        section : str
            A BRENDA enzyme section starting from 'ID   x.x.x.x' until '///'.
        session : sqlalchemy.Session
            A running session for querying database connections.
        kw_args :
            Keyword arguments are passed on to the ply.yacc.yacc.parse call.

        """
        self._session = session
        self.proteins.clear()
        self.citations.clear()
        self._current_entry = None
        return self.parser.parse(section, lexer=self._lexer, **kw_args)

    def p_enzyme(self, p):
        """enzyme : ENTRY EC_NUMBER new_enzyme"""
        LOGGER.debug("%s: %s", self.p_enzyme.__doc__, p[3].ec_number)
        p[0] = p[3]

    def p_new_enzyme(self, p):
        """new_enzyme :"""
        LOGGER.debug("%s: %s", self.p_new_enzyme.__doc__, p[-1])
        assert p[-2] == "ID"
        p[0] = models.Enzyme(ec_number=p[-1])

    def p_enzyme_comment(self, p):
        """enzyme : enzyme comment %prec ENZYME"""
        LOGGER.debug("%s: %s", self.p_enzyme_comment.__doc__, p[1].ec_number)
        if p[2] is not None:
            p[1].comments.append(p[2])
        p[0] = p[1]

    def p_enzyme_protein(self, p):
        """enzyme : enzyme protein_entry %prec ENZYME"""
        LOGGER.debug("%s: %s", self.p_enzyme_protein.__doc__, p[1].ec_number)
        p[1].proteins.append(p[2])
        p[0] = p[1]

    def p_enzyme_reference(self, p):
        """enzyme : enzyme reference_entry %prec ENZYME"""
        LOGGER.debug("%s: %s", self.p_enzyme_reference.__doc__, p[1].ec_number)
        p[1].references.append(p[2])
        p[0] = p[1]

    def p_enzyme_entry(self, p):
        """enzyme : enzyme entry %prec ENZYME"""
        LOGGER.debug("%s: %s", self.p_enzyme_entry.__doc__, p[1].ec_number)
        # TODO: In future, add to specific children based on acronym.
        p[1].entries.append(p[2])
        p[0] = p[1]

    def p_enzyme_end(self, p):
        """enzyme : enzyme END"""
        LOGGER.debug("%s: %s", self.p_enzyme_end.__doc__, p[1].ec_number)
        # TODO: Finalize protein and citation references.
        p[0] = p[1]

    def p_entry(self, p):
        """entry : ENTRY new_entry"""
        LOGGER.debug("%s: %s", self.p_entry.__doc__, p[1])
        assert p[1] == p[2].field.acronym
        p[0] = p[2]

    def p_new_entry(self, p):
        """new_entry :"""
        LOGGER.debug("%s: %s", self.p_new_entry.__doc__, p[-1])
        field = self._session.query(models.InformationField) \
            .filter_by(acronym=p[-1]) \
            .one()
        p[0] = models.FieldEntry(field=field, body="")

    def p_entry_content(self, p):
        """entry : entry CONTENT"""
        LOGGER.debug("%s: %s", self.p_entry_content.__doc__, p[1].field.acronym)
        assert len(p[2]) > 0
        p[1].body += " {}".format(p[2])
        p[0] = p[1]

    def p_entry_comment(self, p):
        """entry : entry comment %prec ASSEMBLE"""
        LOGGER.debug("%s: %s", self.p_entry_comment.__doc__, p[1].field.acronym)
        if p[2] is not None:
            p[1].comment_references.append(p[2])
        p[0] = p[1]

    def p_reference_entry(self, p):
        """reference_entry : REFERENCE_ENTRY new_reference citations"""
        LOGGER.debug("%s: %s", self.p_reference_entry.__doc__,
                     p[2].field.acronym)
        assert len(p[3]) == 1  # Reference entry only has its own number.
        self.citations[p[3][0]] = p[2]
        p[0] = p[2]

    def p_new_reference(self, p):
        """new_reference :"""
        LOGGER.debug("%s: %s", self.p_new_reference.__doc__, p[-1])
        assert p[-1] == "RF"
        field = self._session.query(models.InformationField) \
            .filter_by(acronym=p[-1]) \
            .one()
        p[0] = models.Reference(field=field, body="")

    def p_reference_content(self, p):
        """reference_entry : reference_entry CONTENT"""
        LOGGER.debug("%s: %s", self.p_reference_content.__doc__,
                     p[1].field.acronym)
        assert len(p[2]) > 0
        p[1].body += " {}".format(p[2])
        p[0] = p[1]

    def p_reference_year(self, p):
        """reference_entry : reference_entry comment %prec ASSEMBLE"""
        LOGGER.debug("%s: %s", self.p_reference_year.__doc__,
                     p[1].field.acronym)
        if p[2] is not None:
            p[1].body += " ({})".format(p[2])
        p[0] = p[1]

    def p_reference_pubmed(self, p):
        """reference_entry : reference_entry special %prec ASSEMBLE"""
        LOGGER.debug("%s: %s", self.p_reference_pubmed.__doc__,
                     p[1].field.acronym)
        try:
            p[1].pubmed = p[2]
        except ValidationError:
            pass
        p[0] = p[1]

    def p_protein_entry(self, p):
        """protein_entry : PROTEIN_ENTRY new_protein proteins"""
        LOGGER.debug("%s: %s", self.p_protein_entry.__doc__, p[1])
        assert len(p[3]) == 1  # Protein entry only has its own number.
        self.proteins[p[3][0]] = p[2]
        p[0] = p[2]

    def p_new_protein(self, p):
        """new_protein :"""
        LOGGER.debug("%s: %s", self.p_new_protein.__doc__, p[-1])
        assert p[-1] == "PR"
        field = self._session.query(models.InformationField) \
            .filter_by(acronym=p[-1]) \
            .one()
        p[0] = models.Protein(field=field)

    def p_protein_organism(self, p):
        """protein_entry : protein_entry CONTENT"""
        LOGGER.debug("%s: %s", self.p_protein_organism.__doc__,
                     p[1].field.acronym)
        assert len(p[2]) > 0
        # TODO: Find or create the organism.
        p[1].organism_name += p[2]
        p[0] = p[1]

    def p_protein_accession(self, p):
        """protein_entry : protein_entry ACCESSION CONTENT"""
        LOGGER.debug("%s: %s", self.p_protein_accession.__doc__,
                     p[1].field.acronym)
        # Might have to be split into its own rule if ACCESSION occurs without
        # database (CONTENT).
        p[1].accession = p[2]
        p[1].database = p[3]
        p[0] = p[1]

    def p_protein_citations(self, p):
        """protein_entry : protein_entry citations %prec ASSEMBLE"""
        LOGGER.debug("%s: %s", self.p_protein_citations.__doc__,
                     p[1].field.acronym)
        if p[2] is not None:
            p[1].citation_references.extend(p[2])
        p[0] = p[1]

    def p_special(self, p):
        """special : LCURLY special RCURLY"""
        LOGGER.debug("%s", self.p_special.__doc__)
        p[0] = p[2]

    def p_special_empty(self, p):
        """special : LCURLY RCURLY"""
        LOGGER.debug("%s", self.p_special_empty.__doc__)
        pass

    def p_special_combine(self, p):
        """special : special SPECIAL %prec COMBINE"""
        LOGGER.debug("%s", self.p_special_combine.__doc__)
        p[0] = "{0} {1}".format(p[1], p[2])

    def p_special_end(self, p):
        """special : SPECIAL %prec REDUCE"""
        LOGGER.debug("%s", self.p_special_end.__doc__)
        p[0] = p[1].strip()

    def p_proteins(self, p):
        """proteins : POUND proteins POUND"""
        LOGGER.debug("%s", self.p_proteins.__doc__)
        p[0] = p[2]

    def p_proteins_empty(self, p):
        """proteins : POUND POUND """
        LOGGER.debug("%s", self.p_proteins_empty.__doc__)
        pass

    def p_proteins_combine(self, p):
        """proteins : proteins PROTEIN %prec COMBINE"""
        LOGGER.debug("%s", self.p_proteins_combine.__doc__)
        p[1].append(p[2])
        p[0] = p[1]

    def p_proteins_end(self, p):
        """proteins : PROTEIN %prec REDUCE"""
        LOGGER.debug("%s", self.p_proteins_end.__doc__)
        p[0] = [p[1]]

    def p_citations(self, p):
        """citations : LANGLE citations RANGLE"""
        LOGGER.debug("%s", self.p_citations.__doc__)
        p[0] = p[2]

    def p_citations_empty(self, p):
        """citations : LANGLE RANGLE """
        LOGGER.debug("%s", self.p_citations_empty.__doc__)
        pass

    def p_citations_combine(self, p):
        """citations : citations CITATION %prec COMBINE"""
        LOGGER.debug("%s", self.p_citations_combine.__doc__)
        p[1].append(p[2])
        p[0] = p[1]

    def p_citations_end(self, p):
        """citations : CITATION %prec REDUCE"""
        LOGGER.debug("%s", self.p_citations_end.__doc__)
        p[0] = [p[1]]

    def p_comment(self, p):
        """comment : LPARENS comment RPARENS"""
        LOGGER.debug("%s", self.p_comment.__doc__)
        p[0] = p[2]

    def p_comment_empty(self, p):
        """comment : LPARENS RPARENS"""
        LOGGER.debug("%s", self.p_comment_empty.__doc__)
        pass

    def p_comment_combine(self, p):
        """comment : comment COMMENT %prec COMBINE"""
        LOGGER.debug("%s", self.p_comment_combine.__doc__)
        p[0] = "{0} {1}".format(p[1], p[2])

    def p_comment_end(self, p):
        """comment : COMMENT %prec REDUCE"""
        LOGGER.debug("%s", self.p_comment_end.__doc__)
        p[0] = p[1]

    def p_error(self, p):
        LOGGER.debug("error: %s", str(p))
        # TODO: If `p` is None (we allow some empty rules) it's only an error
        # if any parentheses or similar are unbalanced.
        if False:
            raise SyntaxError(str(p))
